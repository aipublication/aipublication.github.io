---
layout: article
mathjax: true
title: Algorithm for Scheduling Talks
image: "/assets/images/covers/tim-johnson-Vwf8q3RzBRE-unsplash.jpg"
categories:
- DM
desc: ### Objective 
imagealt: Cover Image for article
---

### Objective
Schedule as many talks as possible.
**In this case:** Have largest combined attendance for talks.

### Constraints
* Once a talk starts it proceeds until it ends
* No two talks can overlap each other
* A talk can begin at the same time other talk ends

### Assumptions
We have $n$ talks each beginning at time $s_j$ and ending at time $e_j$, attended by $w_j$ students.




















































































































































































































































































































































































































If a student attends more than one talk then he/she is counted more than one time.

$T(j)$ : Maximum number of total attendance for first $j$ talks using optimal algorithm.




















































































































































































































































































































































































































$T(n)$ : Maximum number of total attendance for all $n$ talks using optimal algorithm.





















































































































































































































































































































































































































### Algorithm
1. Sort the talks in the increasing order of end time.
2. Renumber talks such that $e_1 \le e_2 \le \dots \le e_n$.




















































































































































































































































































































































































































3. Assign a value $p(j)$ for each talk $j$. Value of $p(j)$ is the talk with largest number (out of talks [Compatible]({% post_url 2021-07-08-compatible %}) with $j$) or 0 if such talk dosen't exist.




















































































































































































































































































































































































































4. For $j \le n$ there are two possibilities for optimal schedule of first $j$ talks:




















































































































































































































































































































































































































	a. Talks are in optimal schedule. Then by adding talk $j$ the schedule will get better than overall optimal schedule.




















































































































































































































































































































































































































		$$T(j) = w_j + T(p(j))$$




















































































































































































































































































































































































































	b. Talks are not in optimal schedule. Then optimal schedule from $1, 2, \dots j$ is same as optimal schedule from $1, 2, \dots (j-1)$




















































































































































































































































































































































































































		$$T(j) = T(j-1)$$




















































































































































































































































































































































































































5. Combining case (a) and (b) from step 4 we get a [Recurrence Relation]({% post_url 2021-07-08-recurrence-relation %})
	$$T(j) = max(w_j + T(p(j)), T(j-1))$$





















































































































































































































































































































































































































### Psuedocode
```
func max_attendes(stimes[], etimes[], nattendes[]):
	
	sort_and_relabel(etimes)
	
	for j in (1..n):
		i = i<j and i compatible with j
		
		if i==None:
			p(j)=0
		
		else:
			p(j)=max(i)
		
		T(0) = 0
	
	for j in (1..n):
		T(j) = max(nattendes[j] + T(p(j)), T(j-1))
	
	return T(n)
```



This blog was published directly from my notes.
To check the source of my notes and images used in this blog, visit <a href="/credits.html" target="_blank">Credits</a>.

To read my notes, download this <a href="https://github.com/bovem/CS" target="blank">repository</a>.